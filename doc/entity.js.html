<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Three Arena Source: entity.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	
	<link type="text/css" rel="stylesheet" href="styles/site.flatly.css">
	
</head>

<body>
<div class="container-fluid">
	<div class="navbar navbar-fixed-top navbar-inverse">
		<div class="navbar-inner">
			<a class="brand" href="index.html">Three Arena</a>
			<ul class="nav">
				
				<li class="dropdown">
					<a href="modules.list.html" class="dropdown-toggle" data-toggle="dropdown">Modules<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="bufficon.html">threearena/elements/bufficon</a>
						</li>
						
						<li>
							<a href="lifebar.html">threearena/elements/lifebar</a>
						</li>
						
						<li>
							<a href="nexus.html">threearena/elements/nexus</a>
						</li>
						
						<li>
							<a href="shop.html">threearena/elements/shop</a>
						</li>
						
						<li>
							<a href="sound.html">threearena/elements/sound</a>
						</li>
						
						<li>
							<a href="terrain.html">threearena/elements/terrain</a>
						</li>
						
						<li>
							<a href="tower.html">threearena/elements/tower</a>
						</li>
						
						<li>
							<a href="toxi.html">threearena/elements/toxi</a>
						</li>
						
						<li>
							<a href="water.html">threearena/elements/water</a>
						</li>
						
						<li>
							<a href="demo.html">threearena/examples/demo</a>
						</li>
						
						<li>
							<a href="game.html">threearena/game</a>
						</li>
						
						<li>
							<a href="hud.html">threearena/hud</a>
						</li>
						
						<li>
							<a href="log.html">threearena/log</a>
						</li>
						
						<li>
							<a href="cloud.html">threearena/particles/cloud</a>
						</li>
						
						<li>
							<a href="flies.html">threearena/particles/flies</a>
						</li>
						
						<li>
							<a href="shadercloud.html">threearena/particles/shadercloud</a>
						</li>
						
						<li>
							<a href="snow.html">threearena/particles/snow</a>
						</li>
						
						<li>
							<a href="circles.html">threearena/shaders/circles</a>
						</li>
						
						<li>
							<a href="lightbolt.html">threearena/shaders/lightbolt</a>
						</li>
						
						<li>
							<a href="bite.html">threearena/spell/bite</a>
						</li>
						
						<li>
							<a href="fireaura.html">threearena/spell/fireaura</a>
						</li>
						
						<li>
							<a href="firebullet.html">threearena/spell/firebullet</a>
						</li>
						
						<li>
							<a href="flatfireaura.html">threearena/spell/flatfireaura</a>
						</li>
						
						<li>
							<a href="lightbolt_.html">threearena/spell/lightbolt</a>
						</li>
						
						<li>
							<a href="entityview.html">threearena/views/entityview</a>
						</li>
						
						<li>
							<a href="gameview.html">threearena/views/gameview</a>
						</li>
						
						<li>
							<a href="interactiveview.html">threearena/views/interactiveview</a>
						</li>
						

					</ul>
				</li>
				
				<li class="dropdown">
					<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="character.html">threearena/character</a>
						</li>
						
						<li>
							<a href="007.html">threearena/character/007</a>
						</li>
						
						<li>
							<a href="human.html">threearena/character/human</a>
						</li>
						
						<li>
							<a href="monsterdog.html">threearena/character/monsterdog</a>
						</li>
						
						<li>
							<a href="ogro.html">threearena/character/ogro</a>
						</li>
						
						<li>
							<a href="ratamahatta.html">threearena/character/ratamahatta</a>
						</li>
						
						<li>
							<a href="attackcircle.html">threearena/controls/attackcircle</a>
						</li>
						
						<li>
							<a href="dota.html">threearena/controls/dota</a>
						</li>
						
						<li>
							<a href="selection.html">threearena/controls/selection</a>
						</li>
						
						<li>
							<a href="abovemark.html">threearena/elements/abovemark</a>
						</li>
						
						<li>
							<a href="autospawn.html">threearena/elements/autospawn</a>
						</li>
						
						<li>
							<a href="interactiveobject.html">threearena/elements/interactiveobject</a>
						</li>
						
						<li>
							<a href="entity.html">threearena/entity</a>
						</li>
						
						<li>
							<a href="game_.html">threearena/game</a>
						</li>
						
						<li>
							<a href="spell.html">threearena/spell</a>
						</li>
						
						<li>
							<a href="destinationmarker.html">threearena/spell/destinationmarker</a>
						</li>
						

					</ul>
				</li>
				
				<li class="dropdown">
					<a href="events.list.html" class="dropdown-toggle" data-toggle="dropdown">Events<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="game.html#event:added:entity">added:entity</a>
						</li>
						
						<li>
							<a href="game.html#event:added:spawningpool">added:spawningpool</a>
						</li>
						
						<li>
							<a href="game.html#event:added:static">added:static</a>
						</li>
						
						<li>
							<a href="game.html#event:ready">ready</a>
						</li>
						
						<li>
							<a href="game.html#event:start">start</a>
						</li>
						
						<li>
							<a href="game.html#event:update">update</a>
						</li>
						
						<li>
							<a href="game.html#event:update:behaviours">update:behaviours</a>
						</li>
						

					</ul>
				</li>
				
				<li class="dropdown">
					<a href="global.html" class="dropdown-toggle" data-toggle="dropdown">Global<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="global.html#gcb">gcb</a>
						</li>
						
						<li>
							<a href="global.html#glow">glow</a>
						</li>
						
						<li>
							<a href="global.html#glowmaterial">glowmaterial</a>
						</li>
						
						<li>
							<a href="global.html#moveAlong">moveAlong</a>
						</li>
						
						<li>
							<a href="global.html#unglow">unglow</a>
						</li>
						

					</ul>
				</li>
				
			</ul>
		</div>
	</div>

	<div class="row-fluid">

		
			<div class="span12">
				
				<div id="main">
					


		<h1 class="page-title">Source: entity.js</h1>
    
    <section>
        <article>
            <pre class="sunlight-highlight-javascript linenums">define('threearena/entity',
    ['lodash', 'microevent', 'threejs', 'knockout', 'threearena/log', 'threearena/utils', 'threearena/controls/attackcircle', 'threearena/elements/lifebar', 'threearena/pathfinding/recast.emcc.oem',],

function(_, MicroEvent, THREE, ko, log, Utils, AttackCircle, LifeBar, PathFinding) {
    PathFinding = Module;

    /**
     * A living entity
     *
     * @summary azd azdzad azd zadazd azdzadzadazdazdzd
     * 
     * @exports threearena/entity
     * 
     * @triggers 'changed' when state (attributes, spells, etc) change
     * @triggers 'hit' when being hit
     * @triggers 'death' when being killed
     *
     * @constructor
     * @param {Object} options
     *          name, image, life, mana, strength, agility, intelligence,
     *          spells, level, meleeDef, meleeDamage, spellDefense, spellDamage
     */
    var Entity = function(options) {

        var self = this;

        THREE.Object3D.apply(this);

        this.state = _.merge({

            name: Math.random(),
            image: '/gamedata/unknown.png',

            tomb: '/gamedata/models/rts_elements.dae',

            life: 100,
            mana: 0,

            speed: 50,

            strength: 1,
            agility: 1,
            intelligence: 1,

            spells: [],

            level: 1,

            meleeDefense: 1,
            meleeDamage: 1,

            spellDefense: 1,
            spellDamage: 1,

            attackRange: 0

        }, options);

        this._baseLife = this.state.life;
        this._baseMana = this.state.mana;

        // this.attachLifeBar(); // now done in game.add()
        this.attachTombstone();

        this.bind('death', function(){
            if (this.currentTween) {
                this.currentTween.stop();
            }
            if (this.behaviour) {
                this.behaviour.identifier = 'beDead';
            }
        });

        this._meleeCircle = new AttackCircle(5);
        this.add(this._meleeCircle);
        this._spellCircle = new AttackCircle(20);
        this.add(this._spellCircle);

        this.states = {

            idle: function() { },

            canBeDead: function() { return self.isDead(); },
            beDead: function() { },

            canFightObjective: function () {
                return ! self.isDead() && self.objective && (! self.objective.isDead || ! self.objective.isDead()) && self.state.spells[0].canHit(self, self.objective, 3);
            },
            fightObjective: function () {
                if (self._currentTween) {
                    self._isMoving = false;
                    self._currentTween.stop();
                    self._currentTween.onComplete();
                }
                self._isFighting = true;

                self.cast(self.state.spells[0], self.objective);
            },

            canFightNearbyEnnemy: function () {

                if (self.isDead()) {
                    return false;
                }

                var spell;
                if (self.state.autoAttackSpell !== null && self.state.autoAttacks && self.state.spells[ self.state.autoAttackSpell ]) {

                    var i = -1,
                        charDistance,
                        minDistance = Number.MAX_VALUE,
                        spell = self.state.spells[ self.state.autoAttackSpell ];

                    self._nearestEnnemy = false;
                    while (i++ &lt; game.pcs.length - 1) {
                        if (game.pcs[i].isDead()) continue;

                        charDistance = game.pcs[i].position.distanceTo(self.position);

                        if (charDistance &lt; minDistance && self.state.team != game.pcs[i].state.team && spell.canHit(self, game.pcs[i], 3)) {
                            minDistance = charDistance;
                            self._nearestEnnemy = game.pcs[i];
                        }
                    }
                }
                if (! self._nearestEnnemy) {

                    if (self._isFighting) {
                        // was fighting, must replan
                        self._currentRoute = null;
                        self._isMoving = false;
                    }

                    // nnope, no one's there
                    self._isFighting = false;
                    self._fightingArc = false;
                    return false;

                } else {

                    return true;
                }
            },
            fightNearbyEnnemy: function () {
                if (self._currentTween) {
                    self._isMoving = false;
                    self._currentTween.stop();
                    self._currentTween.onComplete();
                }
                self._isFighting = true;
                self.cast(self.state.spells[0], self._nearestEnnemy);
            },

            plotCourseToObjective: function () {
                self._currentRoute || PathFinding.findPath(
                    self.position.x, self.position.y, self.position.z,
                    self.objective.position.x, self.objective.position.y, self.objective.position.z,
                    100000,
                    Utils.gcb( _.bind( self._setRoute, self) )
                );
            },
            canPlotCourseToObjective: function () {
                return ! self.isDead() && self.objective && ! this._isFighting && ! self._currentRoute;
            },

            followCourseToObjective: function () {
                if (self._isMoving || ! self._currentRoute) return;
                if (self._currentTween) {
                    self._currentTween.stop();
                    self._currentTween.onComplete();
                }
                this._isFighting = false;
                self._currentTween = self.moveAlong(self._currentRoute, {
                    onStart: function(tween){
                        self._isMoving = true;
                    },
                    onComplete: function(tween){
                        self._isMoving = false;
                        if (tween.distance >= 1) {
                            self._currentRoute = null;
                        }
                    }
                });
            },

            canFollowCourseToObjective: function () {
                return ! self.isDead()
                        && self.objective 
                        && self._currentRoute 
                        && ! this._isFighting 
                        && ! self.states.canFightObjective()
                        && ! self.states.canFightNearbyEnnemy();
            },

            moveAttackToObjective: function () {
                self.states.followCourseToObjective();
            },

            canMoveAttackToObjective: function () {
                return ! self.isDead() && (self.objective && self.objective.position.distanceTo(self.position) > 2);
            },

        };

        this.trigger('changed', this.state);
    };

    Entity.prototype = Object.create(THREE.Object3D.prototype);

    //////////////////

    Entity.prototype._setRoute = function (linepoints) {

        if (linepoints && linepoints.length > 0) {
            log(log.SYS_DEBUG, '%o finds a way from %o to %o', this, linepoints[0], linepoints[linepoints.length - 1]);

            this._currentRoute = linepoints; // new THREE.SplineCurve3(linepoints);

        } else {
            this._currentRoute = null;
        }
    }

    Entity.prototype._addRoute = function (linepoints) {

        if (linepoints && linepoints.length > 0) {
            log(log.SYS_DEBUG, '%o finds a way from %o to %o', this, linepoints[0], linepoints[linepoints.length - 1]);

            if (! this._currentRoute) {
                this._nextRoutes = [];
            }

            this._nextRoutes.push(linepoints);
        }

    }

    //////////////////

    /**
     * Attach a life/mana bar above the entity
     */
    Entity.prototype.attachLifeBar = function() {

        this.lifebar = new LifeBar();
    };

    /**
     * Update the character lifebar
     */
    Entity.prototype.updateLifeBar = function() {

        var eventData = {
            life: this._baseLife === false ? false : this._baseLife > 0 ? 1 / this._baseLife * this.state.life : 0,
            mana: this._baseMana === false ? false : this._baseMana > 0 ? 1 / this._baseMana * this.state.mana : 0
        };

        // this.lifebar.position.copy(this.position.x).setY(20);
        this.lifebar.set(eventData);

        this.trigger('changed', eventData);
    };

    /**
     * Attach a tomb, to replace the dead entity
     */
    Entity.prototype.attachTombstone = function() {

        var self = this;
        var loader = new THREE.ColladaLoader();
        loader.load( self.state.tomb, function ( loaded ) {

            self.tomb = loaded.scene.getObjectByName('Cross2');

            self.tomb.castShadow = true;
            self.tomb.rotation.x = -90 * Math.PI / 180;
            self.tomb.scale.set(2, 2, 2);
            self.tomb.position.set(0, 0, 0);

            // when character die, show just a tomb
            self.bind('death', function() {
                self.update = function(){};

                var children = _.clone(self.children);
                _.each(children, function(child){ self.remove(child); });

                children = _.clone(self.character.children);
                _.each(children, function(child){ self.character.remove(child); });

                /*
                for (var i = 0; i &lt; self.children.length; i++) {
                    self.remove(self.children[i]);
                }

                if (self.character) {
                    for (var i = 0; i &lt; self.character.children.length; i++) {
                        self.character.remove(self.character.children[i]);
                    }
                }
                */

                self.add(self.tomb);
            });
        });
    };


    /**
     * Add a life amount
     * @param  {Number} increment
     * @return {Number} new life amount
     */
    Entity.prototype.incrementLife = function(inc) {

        this.state.life = Math.max( 0, this.state.life + inc );
        return this.state.life;
    };

    /**
     * Add a mana amount
     * @param  {Number} inc
     * @return {Number} new mana amount
     */
    Entity.prototype.incrementMana = function(inc) {

        this.state.mana = Math.max( 0, this.state.mana + inc );
        return this.state.mana;
    };

    /**
     * Returns true if entity is dead
     * @return {Boolean}
     */
    Entity.prototype.isDead = function() {

        return this.state.life &lt;= 0;
    };

    /**
     * Returns true if entity is alive
     * @return {Boolean}
     */
    Entity.prototype.isAlive = function() {

        return ! this.isDead();
    };

    /**
     * Returns true if entity is out of mana
     * @return {Boolean}
     */
    Entity.prototype.isOutOfMana = function() {

        return this.state.mana &lt;= 0;
    };

    /**
     * Make the entity move along a path
     * @param  {Array|THREE.Shape} the shape, or the points the entity will walk along
     * @param  {Object} options, such as
     *              start
     *              onStart
     *              onComplete
     *              onUpdate
     * @return {Tween} the Tween.js object
     */
    Entity.prototype.moveAlong = function(linepoints) {

        throw "Parent class Entity cannot move";
    };

    /**
     * Learn a spell
     * @param  {Spell} spell
     * @trigger 'changed'
     */
    Entity.prototype.learnSpell = function(spell) {

        this.state.spells.push(new spell({ source: this }));

        this.trigger('changed', this);
    };

    /**
     * Cast a spell
     * @param  {Spell} spell
     * @return {Boolean} True if spell has been casted
     */
    Entity.prototype.cast = function(spell, target) {

        log(log.COMBAT, '%o begins to cast %o', this, spell);

        // handle cooldown
        if (spell.ccd > 0) {

            // console.log('this spell is not ready yet (%dms)', spell.ccd);
            return;

        } else {
            spell.startCooldown(this);
        }

        // place myself on a correct attacking range arc
        if (spell.isMelee && ! this._fightingArc) {

            var radius  = spell.maxRange + target.state.attackRange,
                start   = (new THREE.Vector3( -radius, 0, 0 )).add(target.position),
                middle  = (new THREE.Vector3( 0, 0, -radius )).add(target.position),
                end     = (new THREE.Vector3(  radius, 0, 0 )).add(target.position);

            this._fightingArc = new THREE.QuadraticBezierCurve3(start, middle, end);
            var p = this._fightingArc.getPointAt(Math.random());

            this.position.set( p.x, p.y, p.z );
        }

        spell.start(this, target);

        return true;
    };

    /**
     * Hit this entity with a spell
     * 
     * @param  {Spell} spell
     * @triggers 'hit', 'changed', 'death'
     */
    Entity.prototype.hit = function(spell) {

        spell.target = this;

        var eventData = {
            dodged: 0,
            meleeLifeDamageReceived: 0,
            magicLifeDamageReceived: 0,
            manaDamageReceived: 0,
            spell: spell
        };

        eventData.meleeLifeDamageReceived = spell.meleeLifeDamage;
        eventData.magicLifeDamageReceived = spell.magicLifeDamage;
        eventData.manaDamageReceived = spell.manaDamage;

        eventData.totalLifeDamage = eventData.meleeLifeDamageReceived + eventData.magicLifeDamageReceived;

        // apply hits
        this.incrementLife(-eventData.totalLifeDamage);
        this.incrementMana(-eventData.manaDamageReceived);

        this.updateLifeBar();

        this.trigger('hit', eventData);

        log(log.COMBAT, '%o hit %o with %o : %d + %d + %d (%s) - %s' ,
            spell.source, this,
            spell.name, eventData.magicLifeDamageReceived, eventData.meleeLifeDamageReceived, eventData.manaDamageReceived,
            (spell.isCritical ? 'critical' : 'normal'), eventData.damageAbsorbed
        );

        // send events & animations
        if (this.isDead()) {

            this.trigger('death', eventData);
            this.character && this.character.setAnimation('death');

        } else {

            this.character && this.character.setAnimation('pain');
        }
    };

    MicroEvent.mixin(Entity);
    return Entity;
});
</pre>
        </article>
    </section>





				</div>

				<div class="clearfix"></div>
				<footer>
					
					
		<span class="jsdoc-message">
		Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.2.0</a>
		on Sat Dec 07 2013 18:26:49 GMT+0100 (CET) using the <a href="https://github.com/terryweiss/docstrap">DocStrap template</a>.
		</span>
				</footer>
			</div>

			
			<br clear="both">
		</div>

	</div>
	<script src="scripts/sunlight.js"></script>
	<script src="scripts/sunlight.javascript.js"></script>
	<script src="scripts/sunlight-plugin.doclinks.js"></script>
	<script src="scripts/sunlight-plugin.linenumbers.js"></script>
	<script src="scripts/sunlight-plugin.menu.js"></script>
	<script src="scripts/jquery.min.js"></script>
	<script src="scripts/jquery.scrollTo.js"></script>
	<script src="scripts/jquery.localScroll.js"></script>
	<script src="scripts/bootstrap-dropdown.js"></script>
	<script src="scripts/toc.js"></script>


	<script>  Sunlight.highlightAll({lineNumbers:true,  showMenu: true, enableDoclinks :true}); </script>

	<script>
		$( function () {
			$( "#toc" ).toc( {
				selectors   : "h1,h2,h3,h4",
				showAndHide : false,
				scrollTo    : 60
			} );
			$( "#toc>ul" ).addClass( "nav nav-pills nav-stacked" );
			$( "#main span[id^='toc']" ).addClass( "toc-shim" );

		} );
	</script>

	

</body>
</html>
